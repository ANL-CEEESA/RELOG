Usage
=====

## 1. Installation

To use RELOG, the first step is to install the [Julia programming language](https://julialang.org/) on your machine. Note that RELOG was developed and tested with Julia 1.5 and may not be compatible with newer versions. After Julia is installed, launch the Julia console, type `]` to switch to package manger mode, then run:

```text
(@v1.5) pkg> add https://github.com/ANL-CEEESA/RELOG.git
```

After the package and all its dependencies have been installed, please run the RELOG test suite, as shown below, to make sure that the package has been correctly installed:

```text
(@v1.5) pkg> test RELOG
```

To update the package to a newer version, type `]` to enter the package manager mode, then run:

```text
(@v1.5) pkg> update RELOG
```

## 2. Modeling the problem

The two main model components in RELOG are **products** and **plants**.

A **product** is any material that needs to be recycled, any intermediary product produced during the recycling process, or any product recovered at the end of the process. For example, in a NiMH battery recycling study case, products could include (i) the original batteries to be recycled; (ii) the cathode and anode parts of the battery; (iii) rare-earth elements and (iv) scrap metals.

* The model assumes that some products are initially available at user-specified locations (described by their latitude, longitude and the amount available), while other products only become available during the recycling process.

* Products that are initially available must be sent to a plant for processing during the same time period they became available.

* Transporting products from one location to another incurs a transportation cost (`$/km/tonne`), spends some amount of energy (`J/km/tonne`) and may generate multiple types of emissions (`tonne/tonne`). All these parameters are user-specified and may be product- and time-specific.

A **plant** is a facility that converts one type of product to another. RELOG assumes that each plant receives a single type of product as input and converts this input into multiple types of products. Multiple types of plants, with different inputs, outputs and performance characteristics, may be specified. In the NiMH battery recycling study case, for example, one type of plant could be a *disassembly plant*, which converts *batteries* into *cathode* and *anode*. Another type of plant could be *anode recycling plant*, which converts *anode* into *rare-earth elements* and *scrap metals*.

* To process each tonne of input material, plants incur a variable operating cost (`$/tonne`), spend some amount of energy (`GJ/tonne`), and produce multiple types of emissions (`tonne/tonne`). Plants also incur a fixed operating cost (`$`) regardless of the amount of material they process. All these parameters are user-specified and may be region- and time-specific.

* Plants can be built at user-specified potential locations. Opening a plant incurs a one-time opening cost (`$`) which may be region- and time-specific. Plants also have a limited capacity (in `tonne`), which indicates the maximum amount of input material they are able to process per year. When specifying potential locations for each type of plant, it is also possible to specify the minimum and maximum capacity of the plants that can be built at that particular location. Different plants sizes may have different opening costs and fixed operating costs. After a plant is built, it can be further expanded in the following years, up to its maximum capacity.

* Products received by a plant can be either processed immediately or stored for later processing. Plants have a maximum storage capacity (`tonne`). Storage costs (`$/tonne`) can also be specified.

* All products generated by a plant can either be sent to another plant for further processing, or disposed of locally for either a profit or a loss (`$/tonne`). To model environmental regulations, it is also possible to specify the maximum amount of each product that can be disposed of at each location.

All user parameters specified above must be provided to RELOG as a JSON file, which is fully described in the [data format page](format.md).

## 3. Running the optimization

After creating a JSON file describing the reverse manufacturing process and the input data, the following example illustrates how to use the package to find the optimal set of decisions:

```julia
# Import package
using RELOG

# Solve optimization problem
solution = RELOG.solve("/home/user/instance.json")

# Write full solution in JSON format
RELOG.write(solution, "solution.json")

# Write simplified reports in CSV format
RELOG.write_plants_report(solution, "plants.csv")
RELOG.write_transportation_report(solution, "transportation.csv")
```

For a complete description of the file formats above, and for a complete list of available reports, see the [data format page](format.md).

## 4. What-If Analysis

Fundamentally, RELOG decides when and where to build plants based on a deterministic optimization problem that minimizes costs for a particular input file provided by the user. In practical situations, it may not be possible to perfectly estimate some (or most) entries in this input file in advance, such as costs, demands and emissions. In this situation, it may be interesting to evaluate how well does the facility location plan produced by RELOG work if costs, demands and emissions turn out to be different.

To simplify this what-if analysis, RELOG provides the `resolve` method, which updates a previous solution based on a new scenario. The method accepts a previous optimal solution, produced by RELOG, and a new input file, which describes the new scenario. The method reoptimizes the supply chain for this new input file, and produces a new solution which still builds the same set of plants as before, in exactly the same locations and with the same capacities, but that may now utilize the plants differently, based on the new data. For example, in the new solution, plants that were previously used at full capacity may now be utilized at half-capacity instead. As another example, regions that were previously served by a certain plant may now be served by a different one.

The following snippet shows how to use the method:

```julia
# Import package
using RELOG

# Optimize for the average scenario
solution_avg = RELOG.solve("input_avg.json")

# Write reports for the average scenario
RELOG.write_plants_report(solution_avg, "plants_avg.csv")
RELOG.write_transportation_report(solution_avg, "transportation_avg.csv")

# Re-optimize for the high-demand scenario, keeping plants fixed
solution_high = RELOG.resolve(solution_avg, "input_high.json")

# Write reports for the high-demand scenario
RELOG.write_plants_report(solution_high, "plants_high.csv")
RELOG.write_transportation_report(solution_high, "transportation_high.csv")
```

To use the `resolve` method, the new input file should be very similar to the original one. Only the following entries are allowed to change:

- **Products:** Transportation costs, energy, emissions and initial amounts (latitude, longitude and amount).
- **Plants:** Energy and emissions.
- **Plant's location:** Latitude and longitude.
- **Plant's storage:** Cost.
- **Plant's capacity:** Opening cost, fixed operating cost and variable operating cost.


## 5. Advanced options

### 5.1 Changing the solver

By default, RELOG internally uses [Cbc](https://github.com/coin-or/Cbc), an open-source and freely-available Mixed-Integer Linear Programming solver developed by the [COIN-OR Project](https://www.coin-or.org/). For larger-scale test cases, a commercial solver such as Gurobi, CPLEX or XPRESS is recommended. The following snippet shows how to switch from Cbc to Gurobi, for example:

```julia
using RELOG, Gurobi, JuMP

gurobi = optimizer_with_attributes(Gurobi.Optimizer,
                                   "TimeLimit" => 3600,
                                   "MIPGap" => 0.001)

RELOG.solve("instance.json",
            output="solution.json",
            optimizer=gurobi)
```

### 5.2 Multi-period heuristics

For large-scale instances, it may be too time-consuming to find an exact optimal solution to the multi-period version of the problem. For these situations, RELOG includes a heuristic solution method, which proceeds as follows:

1. First, RELOG creates a single-period version of the problem, in which most values are replaced by their averages. This single-period problem is typically much easier to solve.

2. After solving the simplified problem, RELOG resolves the multi-period version of the problem, but considering only candidate plant locations that were selected by the optimal solution to the single-period version of the problem. All remaining candidate plant locations are removed.

To solve an instance using this heuristic, use the option `heuristic=true`, as shown below.

```julia
using RELOG

solution = RELOG.solve("/home/user/instance.json",
                       heuristic=true)
```
